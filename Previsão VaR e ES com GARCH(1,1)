library(quantmod)
library(fGarch)
library(rugarch)

startdate <- as.Date("2006-01-01")
enddate <- as.Date("2020-7-27")

# DADOS
tickers <- c("^BVSP","^IXIC")

getSymbols(tickers, src = "yahoo", from = startdate,
           to = enddate)

Retornosmulti = na.omit(cbind(diff(log(IXIC$IXIC.Adjusted)),
                              diff(log(BVSP$BVSP.Adjusted))))

dist1 = "norm"
dist2 = "std"
dist3 = "sstd"
p1 = 0.05
mod = "sGARCH"
Solver <- c("hybrid")

## norm
#Ajustando o GARCH
mod.garch <- try(ugarchspec(variance.model=list(model = mod,
                                                garchOrder = c(1,1)),
                            mean.model=list(armaOrder=c(1,0)),
                            distribution.model = dist1), silent=TRUE)

fit.garch <- try(ugarchfit(mod.garch, data= Retornosmulti$BVSP.Adjusted,
                           solver = Solver), silent=TRUE)
#Prevendo o GARCH
pred.garch <- try(ugarchforecast(fit.garch, 
                                 data=Retornosmulti$BVSP.Adjusted,
                                 n.ahead=1), silent=TRUE)

mu <- fitted(pred.garch)
sig <- sigma(pred.garch)

VaRnorm = -(mu+ sig*qdist(dist1, p=p1, mu = 0, sigma = 1))

func <- function(x) qdist("norm", p=x, mu = 0, sigma = 1)

Int1 <- integrate(func, 0, p1)$value/p1

ESnorm <-  -( mu + sig*Int1)

# std
#Ajustando o GARCH
mod.garch <- try(ugarchspec(variance.model=list(model = mod,
                                                garchOrder = c(1,1)),
                            mean.model=list(armaOrder=c(1,0)),
                            distribution.model = dist2), silent=TRUE)

fit.garch <- try(ugarchfit(mod.garch, data= Retornosmulti$BVSP.Adjusted,
                           solver = Solver), silent=TRUE)
fit.garch


#Prevendo o GARCH
pred.garch <- try(ugarchforecast(fit.garch, 
                                 data=Retornosmulti$BVSP.Adjusted,
                                 n.ahead=1), silent=TRUE)

t.nu <- fit.garch@fit$matcoef[6] # graus de liberdade

func <- function(x) qdist(dist2, p=x, mu = 0, sigma = 1, 
                          shape =  t.nu)

mu <- fitted(pred.garch)
sig <- sigma(pred.garch)

VaRstd = -(mu+ sig*qdist(dist2, p=p1, mu = 0, sigma = 1, 
                         shape =  t.nu))

func1 <- function(x) qdist(dist2, p=x, mu = 0, sigma = 1, 
                           shape =  t.nu)

Int2 <- integrate(func1, 0, p1)$value/p1

ESstd <-  -( mu + sig*Int2)

## HS
VaRHS = -quantile(Retornosmulti$BVSP.Adjusted,p1)
VaRHS
ESHS = -mean(Retornosmulti$BVSP.Adjusted[Retornosmulti$BVSP.Adjusted 
                                         < quantile(Retornosmulti$BVSP.Adjusted,p1)])
ESHS


## FHS
mod.garch <- try(ugarchspec(variance.model=list(model = mod,
                                                garchOrder = c(1,1)),
                            mean.model=list(armaOrder=c(1,0)),
                            distribution.model = dist1), silent=TRUE) # Ajustando o GARCH com dist norm

fit.garch <- try(ugarchfit(mod.garch, data= Retornosmulti$BVSP.Adjusted,
                           solver = Solver), silent=TRUE)

#Prevendo o GARCH
pred.garch <- try(ugarchforecast(fit.garch, 
                                 data=Retornosmulti$BVSP.Adjusted,
                                 n.ahead=1), silent=TRUE)
mu <- fitted(pred.garch)
sig <- sigma(pred.garch)


Resid <- residuals(fit.garch, standardize = T) 
VaRFHS = -(mu + sig*quantile(Resid,p1))
VaRFHS
